#!/bin/bash
#
# pbrisbin 2010
#
# aurget: A simple pacman-like interface to the AUR
#
# http://pbrisbin.com/pages/aurget.html
#
###

# script info {{{
SCRIPT_NAME='Aurget'
SCRIPT_DESCRIPTION='A simple pacman-like interface to the AUR'
SCRIPT_AUTHOR='Patrick Brisbin <pbrisbin@gmail.com>'
SCRIPT_VERSION='3.0.9'
SCRIPT_DATE='8/30/2010'

# }}}

# script utilities {{{
display() { echo -e "${colorB}:: ${colorW}$*${nocolor}"; }

warn() { echo -e "${colorY}warning: ${nocolor}$*"; }

errorout() { 
  echo -e "${colorR}error: ${nocolor}$*"

  [[ -d "$tmpdir" ]] && rm -r "$tmpdir"

  set_lock_file -r

  exit 1
}

builderror() { 
  local pkg="$1" src="$2" dep="$3" msg

  msg="notice: $pkg failed while building, remove source files ($src)"

  # $src must be nonzero so we don't attempt to rm -rf /*
  prompt "$msg" && [[ -n "$src" ]] && rm -rf "$src/"*

  # if it's a dep we need to errorout entirely
  if [[ $dep -eq 1 ]]; then
    errorout "dependency package $pkg failed to build. unable to continue."

  # otherwise, warn but continue
  else
    warn "package $pkg failed to build and won't be installed."
  fi
}

# prompt and return based on choice
prompt() {
  local a

  echo -en "$*? [Y/n] "

  if $noconfirm; then
    echo 'Y'
    return 0
  else
    read a
  fi

  case "${a:-y}" in
    y|Y) return 0     ;;
    q|Q) clean_exit 1 ;;
    *)   return 1     ;;
  esac
}

# uses eval to process --option=value type arguments
runtime_flag() { eval ${1/--/}; }

# prints one array element per line
print_array() {
  local x

  for x in "$@"; do echo $x; done
}

# called before sourcing config or on --nocolor
set_nocolor() {
  # disable pacman color
  pacman="${pacman/pacman-color/pacman}"

  # disable makepkg color
  makepkg="$makepkg --nocolor"

  # disable aurget color
  nocolor=''
  colorW=''
  colorB=''
  colorR=''
  colorG=''
  colorY=''
  colorM=''
}

# set or remove our lock file
set_lock_file() {
  local lock_file='/tmp/aurget.lock'

  if [[ "$1" = '-r' ]]; then
    if [[ -f "$lock_file" ]]; then
      rm "$lock_file" || errorout 'error removing lock file'
    fi

    return 0
  fi

  if [[ -f "$lock_file" ]]; then

    cat << EOF

 $lock_file exists. if you're certain that no other aurget
 process is running, remove this file and try again.

EOF
  exit 1

  fi

  touch "$lock_file" || errorout 'error setting lock file'
}

# clear our temp dir
clear_temp() {
  tmpdir='/tmp/aurget'

  [[ -d "$tmpdir" ]] && rm -r "$tmpdir"
  mkdir -p "$tmpdir"
}

# }}}

# message {{{
message() {
  echo 'usage: aurget [ -v | -h | -S* [ --options ] [ -- ] <arguments> ]'
  echo
  echo '  options:'
  echo
  echo '        -S  <package>   process <package> using your default sync_mode'
  echo
  echo '        -Sd <package>   download <package>'
  echo '        -Sb <package>   download and build <package>'
  echo '        -Sy <package>   download, build, and install <package>'
  echo
  echo '        -Su             process available upgrades using your default sync_mode'
  echo
  echo '        -Sdu            download available upgrades'
  echo '        -Sbu            download and build available upgrades'
  echo '        -Syu            download, build, and install available upgrades'
  echo
  echo '        -Ss  <term>     search aur for <term>'
  echo '        -Ssq <term>     search aur for <term>, print only package names'
  echo '        -Sp  <package>  print the PKGBUILD for <package>'
  echo '        -Si  <package>  print extended info for <package>'
  echo
  echo '        --devel         used with -Su to upgrade all development packages'
  echo
  echo '        --deps          resolve dependencies'
  echo '        --nodeps        don'\''t resolve dependencies'
  echo
  echo '        --edit          prompt to edit all pkgbuilds'
  echo '        --noedit        don'\''t prompt to edit any pkgbuilds'
  echo
  echo '        --discard       discard source files after building'
  echo '        --nodiscard     don'\''t discard source files after building'
  echo
  echo '        --nocolor       disable colorized output'
  echo '        --noconfirm     auto-answer y to all prompts'
  echo
  echo '        --ignore '\''<package> <package> <...>'\'''
  echo '                        add additional packages to be ignored'
  echo
  echo '        --mopt '\''-opt -opt ...'\'''
  echo '                        add additional options to the build command'
  echo
  echo '        --popt '\''-opt -opt ...'\'''
  echo '                        add additional options to the install command'
  echo
  echo '        -v, --version   display version info'
  echo '        -h, --help      display this'
  echo
  echo '        --option=value  set config <option> as <value> for this run only'
  echo

  clean_exit 1
}

# }}}

# version_info {{{
version_info() {
  echo
  echo "  $SCRIPT_NAME: $SCRIPT_DESCRIPTION"
  echo
  echo "  author:      $SCRIPT_AUTHOR"
  echo "  version:     $SCRIPT_VERSION"
  echo "  last update: $SCRIPT_DATE"
  echo

  clean_exit
}

# }}}

# prompt_to_edit {{{
prompt_to_edit() {
  #$prompt_to_edit || return 0

  local pkgbuild reason
  
  pkgbuild="$1"; shift
  reason="${*:-sourcing for deps}"

  [[ ! -f "$pkgbuild" ]] && errorout 'packagebuild not found'

  # default is to prompt
  case "${edit_pkgbuilds:-prompt}" in
    never)  return 0 ;;
    prompt) prompt "edit PKGBUILD before $reason" || return 0 ;;
  esac

  $editor $pkgbuild || errorout 'problem editing PKGBUILD'
  prompt "continue $reason"

#  if prompt "edit PKGBUILD $reason"; then
#    $editor $pkgbuild || errorout 'problem editing PKGBUILD'
#    prompt 'continue'
#  else
#    return 0
#  fi
}

# }}}

# source_pkgbuild {{{
source_pkgbuild() {
  local pkgbuild="$1" tmpfile build 

  [[ ! -f "$pkgbuild" ]] && errorout 'pkgbuild not found'

  tmpfile="$tmpdir/pkgbuild.$$"

  # regex to denote the start of the build function
  build='^build.*(.*)\|^function.*build.*(.*)' 

  # put the top half in a file to be sourced
  grep -B 999 "$build" "$pkgbuild" | grep -v -- "$build" > "$tmpfile"

  # source and remove
  . "$tmpfile" &>/dev/null; rm "$tmpfile"
}

# }}}

# try_discard {{{
try_discard() {
  # we never discard sources
  $discard_sources || return

  # we keep devels and we're doing a devel upgrade
  $dont_discard_devels && $devels && return

  # we keep devels and this is a devel package
  $dont_discard_devels && echo ${1##*/} | grep -q -- "$development_regex" && return

  # use find -delete incase the built package is still in the directory
  display "Discarding sources..."
  find "$1" -depth ! -name "${1##*/}*$pkgext" -delete 2>/dev/null
}

# }}}

# print_pkgbuild {{{
print_pkgbuild() {
  local multiple=false ret=0 url

  # no args returns 1
  [[ ${#args[@]} -eq 0 ]] && clean_exit 1

  # more than one means print names and whitespace
  [[ ${#args[@]} -gt 1 ]] && multiple=true

  for name in "${args[@]}"; do
    $multiple && display "$name/PKGBUILD ==="
    url="$aur_pkgs/$(url_encode "$name/$name")/PKGBUILD"
    wget -q -O - "$url" 2>/dev/null || ret=1
    $multiple && echo
  done

  # finally, exit
  clean_exit $ret
}
# }}}

# url_encode {{{
url_encode() {
  local string="$1" awkscript

  awkscript='
  $1 == "20"                    { printf("%s", "+"); next } # space becomes plus
  $1 ~  /0[adAD]/               {                    next } # strip newlines
  $2 ~  /^[a-zA-Z0-9.*()\/-]$/  { printf("%s", $2);  next } # pass through what we can
                                { printf("%%%s", $1)      } # take hex value of everything else
  '

  # 6/19/2010 + thanks to Irm for this bit of magic
  echo $string | hexdump -v -e '1/1 "%02x\t"' -e '1/1 "%_c\n"' | LANG=C awk "$awkscript"
}
# }}}

# search_aur {{{
search_aur() {
  # just print pkgbuild?
  [[ "$search_mode" = 'print' ]] && print_pkgbuild "${args[@]}"

  # continue with other searches
  local term name Name Version Description URLPath OutOfDate

  term="${args[*]}"

  # do we need exact match or not?
  [[ "$search_mode" = 'info' ]] && name="\"$term\"" || name=''

  # put sorted linesplit JSON data into a file
  wget -q -O - "${aur_srch}$(url_encode "$term")" | sed -e 's/{/\n/g;s/}//g' |\
    grep -F "\"Name\":$name" | sort -t ':' -k 3.2 > "$tmpdir/results.lst"

  # no results
  [[ -s "$tmpdir/results.lst" ]] || clean_exit 1

  # sed-parse that file
  while IFS='|' read -r Name Version Description URLPath OutOfDate; do
    [[ -z "$Name" ]] && continue

    # FYI: http://old.nabble.com/echo-interrupted-by-SIGCHLD-from-a-dying-coprocess-td28028050.html
    case "$search_mode" in
      quiet)  echo "$Name" 2>/dev/null ;;

      info)   [[ "$OutOfDate" =~ ^(1|OutOfDate)$ ]] && outofdate="${colorR}Yes${nocolor}" || outofdate='No'
              echo -e "${colorW}Repository \t: ${colorM}aur${nocolor}"              2>/dev/null
              echo -e "${colorW}Name \t\t: $Name${nocolor}"                         2>/dev/null
              echo -e "${colorW}Version \t: ${colorG}$Version${nocolor}"            2>/dev/null
              echo -e "${colorW}Out of date \t: ${nocolor}$outofdate"               2>/dev/null
              echo -e "${colorW}Description \t: ${nocolor}${Description//\\\///}\n" 2>/dev/null ;;

      search) [[ "$OutOfDate" =~ ^(1|OutOfDate)$ ]] && outofdate="${colorR}[out of date]${nocolor}" || outofdate=''
              echo -en "${colorM}aur/${colorW}$Name"  2>/dev/null
              echo -en " ${colorG}$Version${nocolor}" 2>/dev/null
              echo -e  " $outofdate"                  2>/dev/null
              echo -e  "    ${Description//\\\///}"   2>/dev/null ;;

      *)      errorout 'invalid search_mode'
    esac
  done < <(sed -e 's/\\"/'\''/g' -e 's/.*"Name":"\([^"]*\)".*"Version":"\([^"]*\)".*"Description":"\([^"]*\)".*"URLPath":"\([^"]*\)".*"OutOfDate":"\([^"]*\)".*/\1|\2|\3|\4|\5/g' "$tmpdir/results.lst")

  # cleanup
  rm "$tmpdir/results.lst"
}

# }}}

# upgrade {{{
upgrade() {
  args=()

  display 'Starting AUR upgrade...'
  while read -r name vers; do
    if $devels; then
      # do only devel packages
      echo $name | grep -q -- "$development_regex" || continue
    else
      # skip all devel packages
      echo $name | grep -q -- "$development_regex" && continue
    fi

    # available version 
    versN="$(wget -q -O - "${aur_info}$(url_encode "$name")" | grep -Fv -- '"No result found"' | sed -e 's/.*"Version":"\([^"]*\)".*/\1/g')"

    [[ -z "$versN" ]] && continue

    # check against ignores
    if echo " $ignore_packages " | grep -Fq -- " $name "; then
      warn "$name: ignoring package upgrade ($vers => $versN)"
      continue
    fi

    # devels are just added
    if $devels; then
      args+=("$name")
    else
      # use vercmp
      check=$(vercmp "$vers" "$versN")
      [[ $check -gt 0 ]] && warn "$name: local ($vers) is newer than aur ($versN)"
      [[ $check -lt 0 ]] && args+=("$name")
    fi
  done < <(pacman -Qm)
  
  if [[ ${#args[@]} -ne 0 ]]; then
    setup_targets
  else
    echo ' there is nothing to do'
  fi
}
  
# }}} 

# download_tarball {{{
download_tarball() {
  local name="$1" url="$2" target

  display 'Retrieving source tarball from AUR...'
  target="$srcdir/$name.tar.gz"
  url="${aur}$(url_encode "${url//\\\///}")"
  wget -O "$target" "$url" || errorout 'failed to retrieve aur sources'
  
  # JSON often reports a url, it'll download but won't be a tarball
  if ! file "$target" | grep -Fq 'gzip'; then
    warn "$name: not a valid tarball, trying alternate url..."
    wget -O "$target" "$aur_pkgs/$(url_encode "$name/$name").tar.gz" || errorout 'failed to retrieve aur sources'
  fi

  # stop here if that's how we roll
  [[ "$sync_mode" = 'download' ]] && clean_exit

  # extract
  display 'Extracting source tarball...'
  (cd "$srcdir" && tar xvzf "$target" &>/dev/null) || errorout "$srcdir/$name.tar.gz: failed unpacking the tarball"

  # remove the tarball post extract
  rm "$target"

  # specify sub-sourcedir
  _srcdir="$srcdir/$name"
}

# }}}

# build_package {{{
build_package() {
  local dep="$1" pkgbuild

  display 'Building package...'
  pkgbuild="$(find "$_srcdir/" -name 'PKGBUILD' -print -quit)"
  prompt_to_edit "$pkgbuild" 'building package' || continue

  # explicitly set env vars b/c we don't know if they came from makepkg.conf
  pushd "$(dirname "$pkgbuild")" &>/dev/null || errorout 'failed to change directory'

  # if we fail building, errorout on dep or just return 1 on
  # non-dep
  if ! PKGDEST="$pkgdir" $makepkg $mopts; then
    builderror "$Name" "$_srcdir" "$dep"
    return 1
  fi

  popd &>/dev/null

  # this may or may not discard things
  try_discard "$_srcdir"

  # stop here if that's how we roll
  [[ "$sync_mode" = 'build' ]] && clean_exit

  # try an exact name
  pkg="$pkgdir/$Name-$Version-${CARCH}$pkgext"

  if [[ ! -f "$pkg" ]]; then
    # try any packages
    pkg="$pkgdir/$Name-$Version-any$pkgext"
  fi

  # last resort
  if [[ ! -f "$pkg" ]]; then
    # don't build two dev packages of the same name within the same
    # minute; this is the only way to find git/svn/etc packages' exact
    # filenames
    pkg="$(find "$pkgdir" -ctime -1 -name "$Name-*$pkgext" -print -quit)"
  fi

  return 0
}

# }}}

# install_package {{{
install_package() {
  local pkg="$1" dep="$2"

  display 'Installing package...'

  if [[ -f "$pkg" ]]; then
    if [[ $dep -eq 1 ]]; then
      $pacman --asdep $popts "$pkg" || errorout 'failed installing the package'
    else
      $pacman $popts "$pkg" || errorout 'failed installing the package'
    fi
  else
    errorout "$pkg: package not found"
  fi
}

# }}}

# source_for_deps {{{
source_for_deps() {
  local pkgbuild="$tmpdir/${1}_PKGBUILD"

  # we've already checked this
  [[ -f "$pkgbuild" ]] && continue

  # if this errors, we know it's not aur-available so return 1
  if ! wget -q -O "$pkgbuild" "$aur/packages/$(url_encode "$1/$1")/PKGBUILD"; then
    touch "$pkgbuild"
    return 1
  else
    prompt_to_edit "$pkgbuild" 'sourcing for deps' && source_pkgbuild "$pkgbuild" || continue
  fi
}

# }}}

# dep_check {{{
dep_check() {
  echo 'resolving dependencies...'

  local dep all_deps pac_deps
  all_deps=(); aur_deps=(); pac_deps=() mk_deps=()

  while true; do
    n=${#all_deps[@]}

    for name in "${args[@]}" "${all_deps[@]}"; do
      # keep args out of deps so error messages are more sane
      if ! source_for_deps "$name"; then
        # assume it's a pacman dep for now
        echo " ${args[@]} " | grep -Fq -- " $name " || pac_deps+=("$name")
      else
        echo " ${args[@]} " | grep -Fq -- " $name " || aur_deps=("$name" "${aur_deps[@]}")

        # filter satasfied deps, clear versioning
        depends=( $(pacman -T -- ${depends[@]} ${makedepends[@]}) )
        depends=( $(print_array "${depends[@]}" | sed -e 's/=.*//' -e 's/>.*//' -e 's/<.*//') )

        # store make depends for later removal
        mk_deps+=( ${makedepends[@]} )

        # track unsatisfied deps
        [[ ${#depends[@]} -ne 0 ]] && all_deps=("${depends[@]}" "${all_deps[@]}")
      fi
    done

    # if we found no more deps this round, we can stop
    [[ ${#all_deps[@]} -eq $n ]] && break
  done

  if [[ "${#pac_deps[@]}" -ne 0 ]]; then
    # check a list quickly for availability
    for dep in $(pacman -Si -- "${pac_deps[@]}" 2>&1 >/dev/null | cut -d \' -f 2); do
      # check only the error cases as a possible provides
      pacman -Ssq -- "^$dep$" &>/dev/null || errorout "$dep: dependency cannot be met."
    done

    pac_deps=( $(print_array "${pac_deps[@]}" | sort -u) )

    echo; warn "the following (${#pac_deps[@]}) packages will be installed by pacman: ${pac_deps[@]}"; echo
  fi
}

# }}}

# add_targets_to_list {{{
add_targets_to_list() {
  local name dep Name Version URLPath

  # are we adding these to be installed --asdeps?
  dep="$1"; shift

  for name in "$@"; do
    if echo " $ignore_packages " | grep -Fq -- " $name "; then
      if ! prompt "${colorB}::${colorW} $name is in ignore_packages. Install anyway${nocolor}"; then
        warn "skipping target: $name"
        continue
      fi
    fi

    # fetch JSON
    read -r Name Version URLPath < <(wget -q -O - "${aur_info}$(url_encode "$name")" | grep -Fv -- "\"No result found\"" | sed -e 's/.*"Name":"\([^"]*\)".*"Version":"\([^"]*\)".*"URLPath":"\([^"]*\)".*/\1 \2 \3/g')
    [[ -z "$Name" ]] && errorout "'$name': package not found in AUR."

    # is it already up to date?
    grep -Fqx -- "$Name $Version" "$tmpdir/installed.lst" && warn "$Name-$Version is up to date -- reinstalling"

    # add non-dupes to list of targets
    if ! echo " ${list_names[@]} " | grep -Fx -- " $Name "; then
      list_names+=("$Name")
      list_versions+=("$Version")
      list_urls+=("$URLPath")
      list_deps+=("$dep")
    fi
  done
}

# }}}

# setup_targets {{{
setup_targets() {
  [[ "${#args[@]}" -eq 0 ]] && errorout 'no targets specified (use -h for help)'

  $resolve_dependencies && dep_check

  list_names=(); list_versions=(); list_urls=(); list_deps=()
  pacman -Qm > "$tmpdir/installed.lst"

  echo 'searching AUR...'
  add_targets_to_list 1 "${aur_deps[@]}"
  add_targets_to_list 0 "${args[@]}"

  if [[ ${#list_names[@]} -ne 0 ]]; then
    echo -en "\n${colorY}Targets (${#list_names[@]}):${nocolor} "
    
    for ((i=0; i<${#list_names[@]}; i++)); do
      echo -n "${list_names[i]}-${list_versions[i]} "
    done

    echo; echo; prompt 'Proceed with installation' && process_targets
  else
    errorout 'no targets specified (use -h for help)'
  fi
}

# }}}

# process_targets {{{
process_targets() {
  Name=
  Version=
  URLPath=
  dep=
  pkg=

  for ((i=0; i<${#list_names[@]}; i++)); do
    Name="${list_names[i]}"
    Version="${list_versions[i]}"
    URLPath="${list_urls[i]}"
    dep="${list_deps[i]}"

    download_tarball "$Name" "$URLPath"
    build_package "$dep" || continue
    install_package "$pkg" "$dep"
  done

  # remove make depends
  if $remove_makedepends && [[ ${#mk_deps[@]} -ne 0 ]]; then
    display 'Removing make depends...'
    for mk_dep in ${mk_deps[@]}; do
      pacman --noconfirm -R $mk_dep || warn "unable to remove makedepend $mk_dep"
    done
  fi
}

# }}}

# clean_entrance {{{
clean_entrance() {
  set_lock_file

  [[ $(id -u) -eq 0 ]] && errorout "You should not run aurget as root."

  clear_temp
}

# }}}

# source_config {{{
source_config() {
  local config="$HOME/.aurgetrc"

  # override with XDG if we can
  [[ ! -r "$config" ]] && [[ -d "$XDG_CONFIG_HOME" ]] && config="$XDG_CONFIG_HOME/aurgetrc"

  if [[ ! -r "$config" ]]; then
    echo -e "\n\n==> Note: default config file created at $config <==\n\n"

    cat > "$config" << EOF
#!/bin/bash
#
# aurget config file, generated $(date -R)
#
# use any valid bash to populate the variables.
#
# any config value can be set at runtime via --option=value
#
###

#
# the exact command used to install the built packages. --asdeps will be
# automatically added when appropriate. use --popt to add any
# additional options at runtime.
###
pacman_command='sudo pacman -U'

#
# the exact command used to build packages. use --mopt to add any
# additional options at runtime.
###
makepkg_command='makepkg -s --noconfirm'

#
# by default, the value of \$EDITOR is used to edit pkgbuilds.
# you can override this here if you'd like.
###
pkgbuild_editor=

#
# where to save built packages. leave empty to use the value of PKGDEST
# in makepkg.conf (or the current working directory if that's blank).
###
package_directory=

#
# where to download source files and do the actual building. aurget
# will create subdirectories named after the packages being built.
# leave blank to the use current working directory. this replaces the
# deprecated option source_directory.
###
build_directory=

#
# set this as false to not remove all source files after building a
# package. this has no effect on sources saved using the SRCDEST
# setting in makepkg.conf.
###
discard_sources=true

#
# set this to override the above when building development packages
# as defined by development_regex.
###
dont_discard_devels=true

#
# this regex is matched against package names to determine if a package
# is a development package. development packages are not checked for
# available upgrades but can be upgraded explicitly by passing --devel.
###
development_regex='.*-git$\|.*-hg$\|.*-svn$\|.*-darcs$\|.*-cvs$'

#
# set this to true and aurget will remove all makedepends that were
# installed as part of the operation as the last step in said operation
###
remove_makedepends=false

#
# the default sync mode is the behavior when aurget -S <package> is
# called. it can be one of install, build, or download.
###
sync_mode=install

#
# this determines how the editing of pkgbuilds is handled. it can be
# one of always, never, or prompt. this replaces the deprecated option
# prompt_to_edit (which can still be used). edit_pkgbuilds=prompt is
# analagous to prompt_to_edit=true, and edit_pkgbuilds=never is analagous
# to prompt_to_edit=false
###
edit_pkgbuilds='prompt'

#
# set this as true to automatically resolve all aur dependencies.
###
resolve_dependencies=false

#
# this is a space separated list of package names to be ignored.
###
ignore_packages=''

#
# by default, aurget uses no color. uncomment to enable/customize.
###
#nocolor="\e[0m"   # reset color
#colorW="\e[1;37m" # white
#colorB="\e[1;34m" # blue
#colorR="\e[1;31m" # red
#colorG="\e[1;32m" # green
#colorY="\e[1;33m" # yellow
#colorM="\e[1;35m" # magenta


# don't edit this:
version="$SCRIPT_VERSION"
EOF

  fi

  # set no color as default
  set_nocolor

  . "$config"

  [[ -z "$version" ]] && warn 'config version unknown, this might get weird...'
}

# }}}

# source_makepkg {{{
source_makepkg() {
  local IFS=':' conf confs _PKGDEST
 
  # todo: preserve a PKGDEST environment variable?

  # source these in order
  confs="/etc/makepkg.conf:$HOME/.makepkg.conf"

  for conf in $confs; do
    [[ -r "$conf" ]] && . "$conf"
  done

  # set pkgdir
  pkgdir="${package_directory:-$PKGDEST}"
  pkgdir="${pkgdir:-$PWD}"
  [[ -d "$pkgdir" ]] || mkdir -p "$pkgdir"

  # set srcdir
  # don't use SRCDEST, do check deprecated source_directory
  #srcdir="${source_directory:-$SRCDEST}"
  srcdir="${build_directory:-$source_directory}"
  srcdir="${srcdir:-$PWD}"
  [[ -d "$srcdir" ]] || mkdir -p "$srcdir"

  # this will always be defined by makepkg.conf
  pkgext="${PKGEXT:-.pkg.tar.gz}"
}

# }}}

# set_defaults {{{
set_defaults() {
  source_makepkg

  sync_mode="${sync_mode:-install}"
  search_mode="${search_mode:-search}"

  #prompt_to_edit="${prompt_to_edit:-true}"
  resolve_dependencies="${resolve_dependencies:-false}"

  discard_sources="${discard_sources:-true}"
  dont_discard_devels="${dont_discard_devels:-true}"

  development_regex="${development_regex:-.*-git$\|.*-hg$\|.*-svn$\|.*-darcs$\|.*-cvs$}"
  devels="${devels:-false}"

  noconfirm="${noconfirm:-false}"

  remove_makedepends="${remove_makedepends:-false}"

  # verify enums
  [[ "$edit_pkgbuilds" =~ ^(always|never|prompt)$   ]] || edit_pkgbuilds=prompt
  [[ "$sync_mode"   =~ ^(download|build|install)$  ]] || errorout 'invalid sync mode specified'
  [[ "$search_mode" =~ ^(search|info|quiet|print)$ ]] || errorout 'invalid search mode specified'

  # no dep checking unless installing
  [[ "$sync_mode" != 'install' ]] && resolve_dependencies=false

  # shortcut the deprecated option
  #case "$edit_pkgbuilds" in
  #  always|prompt) prompt_to_edit=true  ;;
  #  never)         prompt_to_edit=false ;;
  #esac
}

# }}}

# parse_options {{{
parse_options() {
  local _opmode=''

  # global var, used by main
  opmode=''

  while [[ -n "$1" ]]; do
    [[ -n "$opmode" ]] && _opmode="$opmode"

    case "$1" in
      -h|--help)     message                                ;;
      -v|--version)  version_info                           ;;
      --)            break                                  ;;
      -S)            opmode='install'                       ;;
      -Sy)           opmode='install'; sync_mode='install'  ;;
      -Sb)           opmode='install'; sync_mode='build'    ;;
      -Sd)           opmode='install'; sync_mode='download' ;;
      -Su)           opmode='upgrade'                       ;;
      -Syu|-Suy)     opmode='upgrade'; sync_mode='install'  ;;
      -Sbu|-Sub)     opmode='upgrade'; sync_mode='build'    ;;
      -Sdu|-Sud)     opmode='upgrade'; sync_mode='download' ;;
      -Ss)           opmode='search' ; search_mode='search' ;;
      -Ssq|-Sqs)     opmode='search' ; search_mode='quiet'  ;;
      -Si|-Ssi|-Sis) opmode='search' ; search_mode='info'   ;;
      -Sp|-Ssp|-Sps) opmode='search' ; search_mode='print'  ;;
      --ignore)      shift; ignore_packages+=" $1"          ;;
      --mopt)        shift; mopts="$1"                      ;;
      --popt)        shift; popts="$1"                      ;;
      --nocolor)     set_nocolor                            ;;
      --noconfirm)   noconfirm=true                         ;;
      --devel)       devels=true                            ;;
      --deps)        resolve_dependencies=true              ;;
      --nodeps)      resolve_dependencies=false             ;;
      --edit)        edit_pkgbuilds='always'                ;;
      --noedit)      edit_pkgbuilds='never'                 ;;
      --discard)     discard_sources=true                   ;;
      --nodiscard)   discard_sources=false                  ;;
      --*=*)         runtime_flag "$1"                      ;;
      -*)            message                                ;;
      *)             args+=("$1")                           ;;
    esac
    shift

    # show help if multiple -S* commands are passed
    [[ -n "$_opmode" ]] && [[ "$_opmode" != "$opmode" ]] && message
  done

  # grab possible args after --
  [[ -n "$*" ]] && args+=("$@")

  # set binaries
  pacman="${pacman_command:-sudo pacman -U}"
  makepkg="${makepkg_command:-makepkg -s --noconfirm}"

  # set editor
  editor="${pkgbuild_editor:-$EDITOR}"
  editor="${editor:-vi}" # a failsafe
}

# }}}

# main {{{
main() {
  case "$opmode" in
    upgrade) upgrade       ;;
    install) setup_targets ;;
    search)  search_aur    ;;
    *)       message       ;;
  esac
}

# }}}

# clean_exit {{{
clean_exit() { 
  set_lock_file -r

  [[ -d "$tmpdir" ]] && rm -r "$tmpdir"

  exit ${1:-0}
}

# }}}

# clean up if we catch signals
trap 'clean_exit 1' TERM HUP QUIT INT

# some url constants
aur='http://aur.archlinux.org'
aur_srch="$aur/rpc.php?type=search&arg="
aur_info="$aur/rpc.php?type=info&arg="
aur_pkgs="$aur/packages"

# run it
clean_entrance
source_config
set_defaults
parse_options "$@"
main
clean_exit

# vim:foldmethod=marker foldmarker={{{,}}}
