I've been looking for a good Haskell project for a while now. The
language is just awesome, and I've been getting more and more
comfortable with it lately thanks to reading
[Real World Haskell](http://www.realworldhaskell.org/blog/). I even
got the opportunity to write some haskell for a project at work
(I'm a consultant on a Microsoft product, crazy).

I wanted something challenging but doable; something to keep me
interested but still stretch my abilities. I had made some smaller
utilities to manage the pages on my site, so I was getting familiar
with parsing XML using some haskell libraries as well as starting
to wrap my head around the IO Monad a bit more. Well, I just
completed (what I think is) a slick little RSS reader using just
haskell and dzen.

For those that don't know, RSS feeds are basically just site
headlines; a very simple XML page that lists items, each item
containing a title, description, and link.

So my reader would read in a listing of feed urls, put together all
of the RSS items from each url, and then display them using dzen.

I put it in the upper right of my left monitor, configured to look
like part of my existing dzen status bars.

The title text remains static and is clickable (opens the url of
the feed item), and the description text is a ticker text that
rolls by right-to-left one character at a time.

### Installation

After some back and forth, I decided this would work best *for me*
as an [XMonad](http://xmonad.org) module. If you're running XMonad,
you can head over to the
[documentation](/xmonad/docs/RssReader.html) and get started
there.

Now this doesn't mean it can't be compiled as a standalone app too.
It just needs a little help.

First, you would have to download `RssReader.hs` and `Dzen.hs` from
my [modules](/xmonad/docs) page and place them in a directory along
side a file called `rssreader.hs`. This file would serve the same
purpose `xmonad.hs` does for XMonad: it would be both a
configuration file and the main application itself, gluing together
imported functions into a runnable `main` function.

Here's an example:

Once that's all set, you can run
`ghc --make -o rssreader rssreader.hs` inside this directory to
create an executable which you can run standalone.

`spawnReader`'s type is `ReaderConf -> Handle -> IO ()`, the subtle
implication of this is that the script doesn't care what you
actually do with its output. It can send its ticker text, one line
at a time, to **anything** that's of the type `Handle`. This can be
a file, simple `stdout`, or the `stdin` of any other program (in
our case, dzen). This means that, if you know haskell, you could
use this module to generate an RssReader using whatever gui toolkit
you wanted -- I'm looking at you conky...

The following packages would be required either from hackage or
your distribution:

-   http
-   tagsoup
-   xmonad-contrib\*

\* I'm being way lazy here in my Dzen module and using
`<a href="http://xmonad.org/xmonad-docs/xmonad-contrib/XMonad-Util-Run.html#v%3AspawnPipe">spawnPipe</a>`
from the xmonad-contrib package. It's a pretty short function, but
since I'm using this as an XMonad module anyway I may or may not
copy it directly into mine.

### Known Issues

Some unprintable characters seem to still come through. I try to
clean the strings as much as possible, but I still see boxes in
dzen from time to time.

The rssreader and the spawned dzen are not tied together
process-wise. This means that you can kill rssreader and a frozen
dzen remains, or you can quit the dzen and rssreader will be left
as a zombie.
